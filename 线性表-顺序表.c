#pragma once


#if 0

#include <malloc.h>
#include "线性表_顺序表.h"


/************************************************************************/
/*  顺序表的建立，也就是顺序表进行初始化，在预先申请内存空间的同时，给变量size和length赋初值：*/
/************************************************************************/
table initTable()
{
	table t;

	t.head=(int*)malloc(Size*sizeof(int));//构造一个空的顺序表，动态申请存储空间
	if (!t.head) //如果申请失败，作出提示并直接退出程序
	{
		printf("初始化失败");
		exit(0);
	}
	t.length=0;//空表的长度初始化为0
	t.size=Size;//空表的初始存储空间为Size
	return t;
}


/************************************************************************/
/* 顺序表插入元素

插入数据元素，无非三种情况：
 1.在表头插入
 2.在表的中间某个位置插入
 3.直接尾随顺序表，作为表的最后一个元素

无论在顺序表的什么位置插入数据元素，解决办法都是：找到要插入的位置，将后续数据元素整体向后移动一个位置，
最后直接在腾出来的位置上插入数据元素。

实现代码： */
/************************************************************************/

//插入函数，其中，elem为插入的元素，add为插入到顺序表的位置

table addTable(table t,int add,int elem)
{
	//判断插入本身是否存在问题（如果插入元素位置比整张表的长度+1还大（如果相等，是尾随的情况），
	//或者插入的位置本身不存在，程序作为提示并自动退出）
	if (add>t.length+1||add<1) {
		printf("插入位置有问题");
		return t;
	}
	//做插入操作时，首先需要看顺序表是否有多余的存储空间提供给插入的元素，如果没有，需要申请
	if (t.length==t.size) {
		t.head=(int *)realloc(t.head, (t.size+1)*sizeof(int));
		if (!t.head) {
			printf("存储分配失败");
			return t;
		}
		t.size+=1;
	}  
	//插入操作，需要将从插入位置开始的后续元素，逐个后移（好好研究这种算法的思想！！！）
	for (int i=t.length-1; i>=add-1; i--) {
		t.head[i+1]=t.head[i];
	}
	//后移完成后，直接将所需插入元素，添加到顺序表的相应位置
	t.head[add-1]=elem;
	//由于添加了元素，所以长度+1
	t.length++;
	return t;
}

/************************************************************************/
/* 顺序表删除元素

在数组中删除元素时，只需将该元素所在位置后的所有数据元素整体前移 1 个位置即可。
前移的过程中被删除元素被后一个元素 覆盖掉，间接实现了删除操作。

实现代码： */
/************************************************************************/

table delTable(table t,int add){
	if (add>t.length || add<1) {
		printf("被删除元素的位置有误");
		exit(0); //exit是系统级别的退出，在退出应用程序之前做了一些处理，保存缓存区的数据，此处应该是return t;
	}
	//删除操作
	for (int i=add; i<t.length; i++) {
		t.head[i-1]=t.head[i];
	}
	t.length--;
	return t;
}


/************************************************************************/
/* 顺序表查找元素

在数组中查找某个数据元素时，可以采取多种查找算法，例如二分查找、插值查找、斐波那契查找算法等。
具体的查找算法以及各自的时间复杂度后续章节会介绍。
根据顺序表中存储的数据的特点，选择合适的算法。这里，采用顺序查找算法（普通的遍历算法）。

实现代码： */
/************************************************************************/

//查找函数，其中，elem表示要查找的数据元素的值
int selectTable(table t,int elem){
	for (int i=0; i<t.length; i++) {
		if (t.head[i]==elem) {
			return i+1;
		}
	}
	return -1;//如果查找失败，返回-1
}



/************************************************************************/
/* 顺序表中更改元素

顺序表中更改数据元素，最简单直接的方式就是：调用查找算法找到该数据元素的位置，直接在该位置上更改。

实现代码： */
/************************************************************************/

//更改函数，其中，elem为要更改的元素，newElem为新的数据元素

table amendTable(table t,int elem,int newElem){
	int add=selectTable(t, elem); //将需要修改元素的下标(地址)赋给address
	t.head[add-1]=newElem;//由于返回的是元素在顺序表中的位置，所以-1就是该元素在数组中的下标
	return t;
}


/************************************************************************/
/*   输出函数 */
/************************************************************************/
void displayTable(table t)
{
	for (int i=0;i<t.length;i++) 
	{
		printf("%d",t.head[i]);
	}
	printf("\n");
}


/************************************************************************/
/*                                                                      */
/************************************************************************/


#endif
